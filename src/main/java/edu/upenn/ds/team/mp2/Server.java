package edu.upenn.ds.team.mp2;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

import edu.upenn.ds.team.service.ChannelHandlerFactory;
import edu.upenn.ds.team.service.NettyNetworkService;
import edu.upenn.ds.team.service.SimpleChannelHandlerFactory;

import java.net.Inet4Address;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;

import java.util.*;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

import static edu.upenn.ds.team.mp2.Utils.getAddressFromId;

/**
 * Server
 * what server do is gossip to 3 other server each 0.3ms,we use ping-ack style gossip, send ping to 
 * other server, and wait for ack,if hasn't receive ack,then we suspect it is failed, so we change 
 * 3 table to suspected. 
 * Suspicion Mechanism: We apply suspicion mechanism to reduce false-positive rate. When a server
 * si hasn’t received ACK from sj, si suspects sj instead of determining sj failed. If si knows the 
 * liveness of a suspected one, it stops suspecting it. If not for timeout (2 sec), the server consider
 * the suspected one FAILED .
 * In this case,we remove that server from membershipTable and suspectTable, also set the server
 * Failed in changeTable, so whenever other server send ping to me, I can piggypack CT and tell them 
 * that sj is failed.
 * we create a ServerInboundChannelHandler(channelRead0) to handle the receive messages
 */

public final class Server {
//The "class" of ID, Status... is generated by avro, something similar to Google Protocol. 
//The definition of ID and others is in the .avsc file in folder src/avro/. 
//http://avro.apache.org/docs/1.8.1/spec.html#Data+Serialization
  private static final Logger LOG = Logger.getLogger(Server.class.getClass().getName());
  private static final int MAX_NUM_CONTACTS = 3;
  private static final int ROUND_PERIOD_MS = 300; // the period for each round
  private static final int SUSPECT_TIMEOUT_MS = 2000; // the timeout to determine that a suspected is dead
  private static final int CHANGE_TABLE_TIMEOUT_MS = 1000; // the timeout for cleaning up the change table
  static final int DEFAULT_PORT = 7000;
  public static volatile boolean stopped = false;

  private final NettyNetworkService networkService;
  //id =<ip, port, startup_timestamp>
  private final Id id;
  private final int port;
  //因为多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap，
  //You should use ConcurrentHashMap when you need very high concurrency in your project.
  //Reads can happen very fast while write is done with a lock.
  
  //When you read from a ConcurrentHashMap using get(), there are no locks, contrary to the HashTable 
  //for which all operations are simply synchronized. 
  private final ConcurrentHashMap<Id, Status> membershipTable;
  private final ConcurrentHashMap<Id, Long> suspectTable;
  /*
  缓存的主要作用是暂时在内存中保存业务系统的数据处理结果，并且等待下次访问使用.缓存的作用就是将这些来自不易的数据保存在内存中，
  当有其他线程或者客户端需要查询相同的数据资源时，直接从缓存的内存块中返回数据，这样不但可以提高系统的响应时间，同时也可以节省对
  这些数据的处理流程的资源消耗，整体上来说，系统性能会有大大的提升。
  可以说在计算机和网络领域，缓存无处不在。可以这么说，只要有硬件性能不对等，涉及到网络传输的地方都会有缓存的身影。
  Guava Cache是一个全内存的本地缓存实现，它提供了线程安全的实现机制
  */
  /*
  http://kveeresham.blogspot.com/2014/08/google-guava-cachebuilder.html
  Google Guava CacheBuilder
  This cache is mainly used where:
  1. Where the same data is retrieved multiple times
  2. Where the time required to access the data to be small
  3. Cache size is limited and known
  */
  private final Cache<Id, Status> changeTable;

  private final BlockingQueue<Id> receivedIds;
  /*
  http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html
  阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。
  当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列
  里拿元素的线程。
  */
  //A socket address has two parts, an IP address and a port number.InetSocketAddress represents a socket 
  //address.
  private InetSocketAddress introducerAddress;
  //used in Launcher.java
  public static Server.Builder newBuilder() {
    return new Builder();
  }

  private Server(final Id id, final int port, final InetSocketAddress address) {
    this.id = id;
    this.port = port;
    this.membershipTable = new ConcurrentHashMap<>();
    this.suspectTable = new ConcurrentHashMap<>();
    //ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。
    //ServerInboundChannelHandler will put new objects into receivedIds
    this.receivedIds = new ArrayBlockingQueue<>(2 * MAX_NUM_CONTACTS);
    
    this.changeTable = CacheBuilder.newBuilder()
    //To clean up the CT, we use timeout (1 sec) to evict old entries that are already disseminated into other nodes.
    //Expire after write: Cache automatically removes the entry once the time is elapsed after the last write.
        .expireAfterWrite(CHANGE_TABLE_TIMEOUT_MS, TimeUnit.MILLISECONDS)//最后一次写入后的一段时间移出,写后1秒过期
        .maximumSize(100) //缓存大小为100
        .build();
    this.introducerAddress = address;
    final ServerInboundChannelHandlerFactory serverInboundChannelHandlerFactory =
        new ServerInboundChannelHandlerFactory(id, membershipTable, changeTable, suspectTable, receivedIds);
    final ChannelHandlerFactory outboundChannelHandlerFactory =
        new SimpleChannelHandlerFactory(OutboundChannelHandler.class);
    this.networkService = NettyNetworkService.newBuilder()
        .setServerGroupNum(2) // to be simple
        .addServerChannelHandlerFactory(serverInboundChannelHandlerFactory)
        .addServerChannelHandlerFactory(outboundChannelHandlerFactory)
        .addClientChannelHandlerFactory(new SimpleChannelHandlerFactory(ClientInboundChannelHandler.class))
        .addClientChannelHandlerFactory(outboundChannelHandlerFactory)
        .setMessageType(Message.class)
        .build();
    serverInboundChannelHandlerFactory.setNetworkService(networkService);
  }

  private void initialize() throws InterruptedException {
    LOG.log(Level.INFO, "Put itself {0} into the membership list", id);
    membershipTable.put(id, Status.ACTIVE);
    changeTable.put(id, Status.JOIN);
    if (introducerAddress != null) {
      join();
    }
  }

  private void join() throws InterruptedException {
    // send a message to introducer
    LOG.log(Level.INFO, "Send a join message to the introducer {0}", introducerAddress);
    final Message msg = Message.newBuilder()
        .setType(Type.JOIN)
        .setSenderId(id)
        .build();

    networkService.send(introducerAddress, msg);

    // wait for a response for the join message
    if (receivedIds.poll(3000, TimeUnit.MILLISECONDS) == null) {
      //取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null
      //failed to receive a response for join
      //try agin
      networkService.send(introducerAddress, msg);
      if (receivedIds.poll(3000, TimeUnit.MILLISECONDS) == null) {
        // hasn't received any message from the introducer
        throw new RuntimeException("Failed to receive a membership list from the introducer " + introducerAddress);
      }
    }
  }
/*
first initialize itself:
1.put itself into membershipTable and changetable and set status active
2.check if it has introduce server:Every server s could be an introducer as long as the new joiner knows 
the IP and port of s.
if we have introdece server, we will send back join to tell the introducer that I am already created and
active now. 
1)Also,If a server s receives JOIN, s takes a role of the introducer. It sends its Membership Table
back in a JOIN_ACK and updates the new node’s status as JOIN in CT. 
2)On receiving JOIN_ACK, s initializes its MT in the message and sets its status in CT as JOIN . 
3)When it receives PING , s sends back ACK on which Change Table is piggybacked to the PING sender. 
4)On receiving ACK , s updates its Membership Table with the received table (another’s CT) in ACK . For 
each entry <id, status> in the received table,

then go to the loop to gossip.
After a server s joins the network, s periodically (0.3 second) picks a fixed number of servers
(contactList) , sends PING to them, and wait fo r the response. If s hasn’t received ACK from si until
next period, s will denote si as SUSPECTED and add it to ST (Suspicion Mechanism). Status changes
will be disseminated through Change Table carried by ACK messages.
*/
  public void run() {
    LOG.log(Level.INFO, "Server ({0}) gets started", id);
    try {
      networkService.start(port);

      initialize();

      // generate a ping message
      final Message ping = Message.newBuilder()
          .setType(Type.PING)
          .setSenderId(id)
          .build();

      while (!stopped) {
  /*
  each server “randomly” chooses m(=3) members to
  contact in each iteration. For both the randomness and completeness for failure detection, we
  create a new queue from the membership list and permute it randomly. In each iteration,
  take m ids from the queue. If the queue is empty, a new randomly permutated queue is built.
  */
        LOG.log(Level.FINER, "Fetch active ids from the membership table");
        final Queue<Id> activeIds = getActiveIds();
        while (!stopped && activeIds.size() > 0) {
          LOG.log(Level.FINER, "Start to ping");
          // pick nodes
          final List<Id> targets = getTargets(activeIds);
          // send a ping message to targets
          for (final Id targetId : targets) {
            LOG.log(Level.FINER, "Send a ping to {0}", targetId);
            networkService.send(getAddressFromId(targetId), ping);
          }

          TimeUnit.MILLISECONDS.sleep(ROUND_PERIOD_MS);

          // check responses from targets
          final List<Id> receivedList = new ArrayList<>(MAX_NUM_CONTACTS);
          //draining from blockingQueue into receivedList
          ///移除此队列中可用的元素，并将它们添加到给定 receivedList 中。
          receivedIds.drainTo(receivedList);
          for (final Id targetId : targets) {
            if (receivedList.indexOf(targetId) != -1) {
              continue;
            }
            // has not received a response from the target
            // suspect it to be dead
            if (membershipTable.get(targetId) == Status.ACTIVE &&
                suspectTable.putIfAbsent(targetId, System.currentTimeMillis()) == null) { // put it into the suspectTable
              // it is suspected for the first time.
              LOG.log(Level.INFO, "Not received a response from {0}. SUSPECT", targetId);
              membershipTable.put(targetId, Status.SUSPECTED); // it should be active before
              changeTable.put(targetId, Status.SUSPECTED);
            }
          }
          //in ServerInboundChannelHandler, when the server receive ACK from other server(with CT),if that 
          //suspected server is active in CT,then we use mergeActive() which remove that server from suspectTable
          //Or if it receive that suspect server in the next round, we also think it is active
          //check suspects whether it is timed out
          final long currentTime = System.currentTimeMillis();
          for (final Map.Entry<Id, Long> entry : suspectTable.entrySet()) {
            final Id targetId = entry.getKey();
            if (currentTime - entry.getValue() > SUSPECT_TIMEOUT_MS) {
              if (membershipTable.get(targetId) == Status.SUSPECTED) {
                LOG.log(Level.INFO, "{0} is considered FAILED", targetId);
                changeTable.put(targetId, Status.FAILED);
                membershipTable.remove(targetId); // remove from the membership table
              }
              // already mark it as failed.
              // just remove it from the suspected table if necessary.
              suspectTable.remove(targetId); // remove from suspectTable
            }
          }
        }
      }
    } catch (final Exception e) {
      LOG.log(Level.SEVERE, "Exception is thrown", e);
    } finally {
      LOG.log(Level.INFO, "Shutdown network service");
      networkService.stop();
      networkService.waitForClose();
    }
  }

  private List<Id> getTargets(final Queue<Id> activeIds) {
    final List<Id> targets = new ArrayList<>(MAX_NUM_CONTACTS);
    while (targets.size() < MAX_NUM_CONTACTS && activeIds.size() > 0) {
      final Id target = activeIds.poll();
      if (membershipTable.containsKey(target)) { // only send a ping to ACTIVE or SUSPECTED one
        targets.add(target);
      }
    }
    return targets;
  }

  private Queue<Id> getActiveIds() {
    final List<Id> ids = new ArrayList<>(membershipTable.size());
    for (final Id targetId : membershipTable.keySet()) {
      if (id.equals(targetId)) {
        continue;
      }
      ids.add(targetId);
    }
    //The shuffle(List<?>) method is used to randomly permute the specified list using 
    //a default source of randomness.
    // for random pick
    Collections.shuffle(ids);
    return new ArrayDeque<>(ids);
  }

  static final class Builder {
    private int port = DEFAULT_PORT;
    private InetSocketAddress introduerAddress;

    private Builder() {
    }

    public Builder setPort(final int port) {
      this.port = port;
      return this;
    }

    public Builder setIntroduerAddress(final InetSocketAddress address) {
      this.introduerAddress = address;
      return this;
    }

    public Server build() {
      // generate Id
      final Id newID = Id.newBuilder()
          .setHostname(getLocalhostAddress())
          .setPort(port)
          .setTs(System.currentTimeMillis())
          .build();
      return new Server(newID, port, introduerAddress);
    }
  }

  private static String getLocalhostAddress() {
    try {
      return Inet4Address.getLocalHost().getHostAddress();
    } catch (final UnknownHostException e) {
      LOG.log(Level.SEVERE, "Failed to get localhost name", e);
      throw new RuntimeException(e);
    }
  }
}
